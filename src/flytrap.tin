# flytrap.tcl
################################################################################
# Debugging and dev tools for Tcl

# Copyright (C) 2023 Alex Baker, ambaker1@mtu.edu
# All rights reserved. 

# See the file "LICENSE" in the top level directory for information on usage, 
# redistribution, and for a DISCLAIMER OF ALL WARRANTIES.
################################################################################

package require wob 0.2.1

# Define namespace
namespace eval ::flytrap {
    # Internal variables
    variable DEBUG 0; # For testing flytrap and pause (no interactive mode)
    variable INFO ""; # Pause line info dictionary (defined in InterpretFrame)
    variable debugType; # -file or -body. For "flytrap" and "debug"
    variable debugBody; # Command passed to internal Eval command
    variable maxDepth; # Maximum debug depth
    variable verboseFlag; # Whether debug is verbose, or only prints on error.
    variable baseLevel; # Level at which the debug command was called
    variable stepHistory; # History of enter and leave traces in Eval
    variable errorStack; # Commands evaluated before error
    variable excludeList {catch try}; # Commands to ignore when in debug
    variable myLocation [file normalize [info script]]; # library file path
       
    # Exported commands
    namespace export pause; # Enter interactive mode in current level
    namespace export flytrap; # Catch bugs in a Tcl script
	namespace export viewVars; # Open an interactive variable viewer widget
}

# pause --
#
# Pauses the script, states the source file and line number it is on, 
# and then enters the event loop, processing user input.
# Pressing enter continues the analysis.
# To pass results to caller, use return.
# When in DEBUG mode, does not pause, just returns INFO
#
# Syntax:
# pause

proc ::flytrap::pause {} {
    variable DEBUG
    variable INFO ""
    # Get frame info of caller
    set i [info frame]
    set INFO [GetFrameInfo [incr i -1]]
    # If DEBUG, just return the line info (for testing)
    if {$DEBUG} {
        return $INFO
    }
    # Print pause line information and enter interactive mode
    puts "PAUSED...\n($INFO)"
    uplevel 1 [list ::wob::mainLoop break]
}

# GetFrameInfo --
#
# Private procedure used by both pause and flytrap to get frame info to display.
#
# Syntax:
# GetFrameInfo $frame $addLines
#
# Arguments:
# frame         Frame dictionary to interpret
# addLines      Lines to add.

proc ::flytrap::GetFrameInfo {min} {
    variable DEBUG
    set i $min; # Minimum frame number
    set addLines 0
    set lineInfo [dict create]
    for {set i $min} {$i > 0} {incr i -1} {
        set frame [info frame $i]
        puts "$i: $frame"
        set type [dict get $frame type]
        if {$type eq "precompiled"} {
            continue
        }
        set line [dict get $frame line]
        incr line $addLines
        set lineInfo [dict create line $line]
        switch [dict get $frame type] {
            source { # Frame is a source frame
                set file [dict get $frame file]
                dict set lineInfo file "\"$file\""
                break
            }
            proc { # Frame is a proc frame
                if {[dict exists $frame proc]} {
                    # Normal proc call
                    dict set lineInfo proc [dict get $frame proc]
                } elseif {[dict exists $frame method]} {
                    # TclOO method call
                    dict set lineInfo method [dict get $frame method]
                    dict set lineInfo class [dict get $frame class]
                    # In Tcl 8.6.10, there is no call frame for the file in 
                    # which the constructor is defined. And for the destructor,
                    # the calling file line number is -1. So simply return the
                    # line number in the constructor/destructor.
                    if {[dict get $frame method] in {
                        <constructor> <destructor>
                    }} then {
                        break
                    }
                }
                set addLines 0
            }
            eval { # Frame is a command evaluation. 
                if {$evalLines == 0} {
                    set cmd [dict get $frame cmd]
                    dict set lineInfo cmd "\{$cmd\}"
                }
                
                # This needs to work for both interp debug {} -frame 0 and 1
                
                if {[interp debug {}] eq "-frame 0"} {
                    if {[lindex $cmd 0] in {eval uplevel}} {
                        # continue
                    }
                }
                incr addLines $line
                incr addLines -1
            }
        }
    }
    return [join $lineInfo]
}

# flytrap --
#
# Step through a script, expanding out all commands using enter/leave traces
# If verbose, prints out everything. If not, only the commands up to an error.
# When an error is encountered, it pauses there and displays the line INFO.
# When in DEBUG mode, it does not pause, just catches the error and returns INFO
# 
# Syntax:
# flytrap -file $filename <$depth> <$verbose> <$varName>
# flytrap -body $script <$depth> <$verbose> <$varName>
#
# Arguments:
# filename      File path of file to source (only with -file)
# script        Tcl script to eval (only with -body)
# depth         Debug depth. Default 0. Steps into procedures if > 0
# verbose       To print out commands and intermediate steps. Default 0

proc ::flytrap::flytrap {type input {depth 0} {verbose 0}} {
    variable DEBUG
    variable INFO ""
    variable debugType $type
    variable debugBody ""
    variable maxDepth $depth
    variable verboseFlag $verbose
    variable baseLevel [info level]
    variable stepHistory ""
    variable errorStack ""
    
    # Determine debugBody from debugType
    switch $debugType {
        -file {set debugBody [list source $input]}
        -body {set debugBody $input}
        default {return -code error "unknown option $debugType"}
    }

    # Check input
    if {![string is integer $depth] || $depth < 0} {
        return -code error "Depth must be integer >= 0"
    }

    # Evaluate command with recursive execution trace
    trace add execution Eval enterstep ::flytrap::EnterStep
    trace add execution Eval leavestep ::flytrap::LeaveStep
    catch {Eval $debugBody} result options
    trace remove execution Eval enterstep ::flytrap::EnterStep
    trace remove execution Eval leavestep ::flytrap::LeaveStep
    # Handle debug case
    if {$DEBUG} {
        return $INFO
    }
    # Return normally to user
    return -options $options $result
}

# Eval --
#
# Private procedure to evaluate code, while being debugged.
#
# Arguments:
# body:     Body of code to evaluate

proc ::flytrap::Eval {body} {uplevel 2 $body}

# EnterStep --
# 
# Private procedure to print out intermediate steps

proc ::flytrap::EnterStep {cmdString args} {
    variable debugType
    variable debugBody
    variable maxDepth
    variable verboseFlag
    variable baseLevel
    variable stepHistory
    variable errorStack
    set depth [expr {[info level] - $baseLevel}]
    if {$depth <= $maxDepth} {
        if {$cmdString ne [list uplevel 2 $debugBody]} {
            lappend errorStack $cmdString; # push
            if {[llength $errorStack] == 1 && $debugType eq "-file"} {
                return
            }
            if {$verboseFlag} {
                set prefix [string repeat "  " $depth]
                puts "$prefix> $cmdString"
            }
            lappend stepHistory enter $depth $cmdString
        }; # end if command not main uplevel
    }; # end if valid depth
    return
}

# LeaveStep --
# 
# Private procedure to print out results from intermediate steps

proc ::flytrap::LeaveStep {cmdString code result args} {
    variable DEBUG
    variable INFO
    variable debugType
    variable debugBody
    variable maxDepth
    variable verboseFlag
    variable baseLevel
    variable stepHistory
    variable errorStack
    variable excludeList
    variable myLocation
    
    set depth [expr {[info level] - $baseLevel}]
    if {$depth > $maxDepth} {
        return
    }
    # Handle command and error stacks
    if {$cmdString ne [list uplevel 2 $debugBody]} {
        set errorStack [lreplace $errorStack end end]; # pop
        if {$verboseFlag} {
            set prefix [string repeat "  " $depth]
            if {$result ne ""} {puts "$prefix$result"}
        }
        lappend stepHistory leave $depth $result
    }; # end if command not main uplevel
    # If not an error, return
    if {$code != 1} {
        return
    }
    # Verify that the error is not wrapped by a built-in error handler
    foreach command $errorStack {
        if {[lindex $command 0] in $excludeList} {
            return
        }
    }
    # Print command history if not verbose
    if {!$verboseFlag} {
        foreach {type depth string} $stepHistory {
            set prefix [string repeat "  " $depth]
            switch $type {
                enter {puts "$prefix> $string"}
                leave {if {$result ne ""} {puts "$prefix$string"}}
            }
        }
    }

    # Get location of error from frame stack
    set i [info frame]
    set INFO [GetFrameInfo [incr i -2]]; # -1 is LeaveStep. -2 is the user code
    # Print error line information and enter interactive mode
    if {!$DEBUG} {
        puts "ERROR...\n($INFO)"
        uplevel 1 [list ::wob::mainLoop break]
    }
    # Remove traces, which then unwinds the interpreter
    trace remove execution Eval enterstep ::flytrap::EnterStep
    trace remove execution Eval leavestep ::flytrap::LeaveStep

    return
}

# viewVars --
#
# Widget for viewing variables. Requires package Tktable
#
# Syntax:
# viewVars <$varList>
#
# Arguments:
# varList       Variables to view. By default, "info vars"

proc ::flytrap::viewVars {args} {
    # Create widget interpreter and ensure required packages are available
    if {[llength $args] == 0} {
        set varList [uplevel 1 {info vars}]
    } elseif {[llength $args] == 1} {
        set varList [lindex $args 0]
    } else {
        ::errmsg::wrongNumArgs "viewVars ?varList?"
    }
    
    # Create widget and require Tktable.
    set widget [::wob::widget new "Workspace"]
    $widget eval {package require Tktable}
    
    # Initialize cells with headers
    $widget set cells(0,0) "Variable"
    $widget set cells(0,1) "Value"
    
    # Fill with sorted variables and values
    set i 1
    foreach varName $varList {
        upvar 1 $varName var
        if {![info exists var]} {
            $widget destroy
            return -code error "$varName does not exist"
        }
        if {[array exists var]} {
            # Array case
            foreach key [lsort [array names var]] {
                $widget set cells($i,0) ${varName}($key)
                $widget vlink var($key) cells($i,1)
                incr i
            }
        } else {
            # Scalar case
            $widget set cells($i,0) $varName
            $widget vlink var cells($i,1)
            incr i
        }
    }
    
    # Create workspace widget
    $widget eval {
        # Create frame, scroll bar, and button
        frame .f -bd 2 -relief groove
        scrollbar .f.sbar -command {.f.tbl yview}
        
        # Create table
        set n [expr {[array size cells]/2}]
        table .f.tbl -rows $n -cols 2 -yscrollcommand {.f.sbar set}
        .f.tbl configure -titlerows 1 -titlecols 1 -height 10 -width 2
        .f.tbl configure -anchor nw  -multiline 0 -ellipsis "..."
        .f.tbl configure -rowseparator " " -colseparator "\n"
        .f.tbl configure -selectmode single -invertselected 1 
        .f.tbl configure -variable cells -state disabled
        .f.tbl configure -rowstretchmode all; # stretches all rows
        .f.tbl configure -colstretchmode unset; # only stretches value col
        .f.tbl tag configure active -fg black
        .f.tbl height 0 1; # Height of title row 
        .f.tbl width 0 25 1 50; # Width of var and val columns

        # Arrange widget
        grid .f -column 0 -row 0 -columnspan 2 -rowspan 2 -sticky nsew
        grid .f.tbl -column 0 -row 1 -columnspan 1 -rowspan 1 -sticky nsew
        grid .f.sbar -column 1 -row 1 -columnspan 1 -rowspan 1 -sticky ns
        grid columnconfigure . all -weight 1
        grid rowconfigure . all -weight 1
        grid columnconfigure .f .f.tbl -weight 1
        grid rowconfigure .f .f.tbl -weight 1
    }
    return $widget
}


# Finally, provide the package
package provide flytrap @VERSION@
